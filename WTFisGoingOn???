#include <iostream>
#include <string>
#include <queue>
#include <utility>

using std::string;
using std::vector;

struct Node {
public:
    Node(string& str, char move, Node* parent_) : position(str), movement(move), parent(parent_) {
    }

    string position; //should have the size of 9
    char movement;  // U/D/R/L/N
    Node *parent;
};

string moveBone(string str, int position, char where) {
    if (where == 'L') {
        std::swap(str[position], str[position - 1]);
    } else if (where == 'R') {
        std::swap(str[position], str[position + 1]);
    } else if (where == 'D') {
        std::swap(str[position], str[position + 3]);
    } else {
        std::swap(str[position], str[position - 3]);
    }
    return str;
}

bool EightGame(Node* rootPosition, string &ans, const unsigned int size) {
    int inversionNum = 0;
    for (int first = 0; first < size; ++first) {
        for (int second = first + 1; second < size; ++second) {
            if (rootPosition->position[first] > rootPosition->position[second]) {
                ++inversionNum;
            }
        }
    }
    if (inversionNum % 2) {
        return false;
    }
    vector<Node*> nodeVector; // умные указатели не забудь добавить, это тебе считается костылём :)
    nodeVector.push_back(rootPosition);
    int pos = 0;
    while (true) { // Он когда-то точно остановится, т.к. чётность к-ва беспорядков совпадает
        Node* currentNode = nodeVector[pos];
        std::cout<<pos<<"\n";
        ++pos;
        if (currentNode->position == "123456780") {
            string reversedAns;
            while (currentNode->parent) {
                reversedAns.push_back(currentNode->movement);
                currentNode = currentNode->parent;
            }
            while (!reversedAns.empty()) {
                ans.push_back(reversedAns.back());
                reversedAns.pop_back();
            }
            for(Node* ptr: nodeVector){
                delete ptr;
            }
            return true;
        }

        int zeroPosition = currentNode->position.find('0');
        if (zeroPosition % 3 != 2 && currentNode->movement != 'L') {
            string newPosition = moveBone(currentNode->position, zeroPosition, 'R');
            Node* nodeToPush = new Node(newPosition, 'R', currentNode);
            nodeVector.push_back(nodeToPush);
        }
        if (zeroPosition % 3 != 0 && currentNode->movement != 'R') {
            string newPosition = moveBone(currentNode->position, zeroPosition, 'L');
            Node* nodeToPush = new Node(newPosition, 'L', currentNode);
            nodeVector.push_back(nodeToPush);
        }
        if (zeroPosition > 2 && currentNode->movement != 'D') {
            string newPosition = moveBone(currentNode->position, zeroPosition, 'U');
            Node* nodeToPush = new Node(newPosition, 'U', currentNode);
            nodeVector.push_back(nodeToPush);
        }
        if (zeroPosition < 6 && currentNode->movement != 'U') {
            string newPosition = moveBone(currentNode->position, zeroPosition, 'D');
            Node* nodeToPush = new Node(newPosition, 'D', currentNode);
            nodeVector.push_back(nodeToPush);
        }


    }

}


int main() {
    const unsigned int size = 9;
    string firstPosition;
    for (int i = 0; i < size; ++i) {
        char next;
        std::cin >> next;
        firstPosition.push_back(next);
    }
    Node* rootNode = new Node(firstPosition, 'N', nullptr);
    string answer;
    if (EightGame(rootNode, answer, size)) {
        std::cout << answer.size() << "\n";
        std::cout << answer;
    } else {
        std::cout << -1;
    }


}
